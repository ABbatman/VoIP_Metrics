<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Call Metrics Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-grid.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-theme-alpine.css" />
  <script src="https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.noStyle.js"></script>
</head>
<body class="bg-gray-100 text-gray-800 p-6">
  <div class="w-full mx-auto px-4">
    <h1 class="text-2xl font-bold mb-6">Monitoring by Burcovschi</h1>
    <!-- Filters Section -->
    <div class="w-full overflow-visible">
      <div class="flex items-center gap-2 w-full justify-start flex-nowrap overflow-visible max-w-full mx-auto px-2">

        <!-- Filter fields -->
        <input id="customerInput" placeholder="Customer" class="px-3 py-2 border rounded flex-grow min-w-0 basis-0 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 my-1" />
        
        <button
          id="reverseButton"
          onclick="toggleReverse()"
          title="Toggle direction"
          class="text-xl px-2 py-2 border rounded bg-gray-200 hover:bg-gray-300 active:bg-gray-400 my-1"
        >
          üîÅ
        </button>

        <input id="supplierInput" placeholder="Supplier" class="px-3 py-2 border rounded flex-grow min-w-0 basis-0 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 my-1" />
        <input id="destinationInput" placeholder="Destination" class="px-3 py-2 border rounded flex-grow min-w-0 basis-0 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 my-1" />
        <input id="fromDate" type="date" class="px-3 py-2 border rounded flex-grow min-w-0 basis-0 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 my-1" />

        <!-- From time -->
        <div class="flex flex-col flex-grow min-w-0 basis-0 my-1 relative">
            <input
                id="fromTime"
                type="time"
                step="1"
                class="px-3 py-2 border rounded w-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1"
                onfocus="showTimeControls('fromTimeControls')"
            />
            <div id="fromTimeControls" class="flex gap-1 hidden mt-1 absolute left-1/2 -translate-x-1/2 top-full z-10">
                <button onclick="adjustTime('fromTime', -1)" class="text-sm px-2 py-1 bg-gray-200 rounded">‚àí</button>
                <button onclick="setNow('fromTime')" class="text-sm px-2 py-1 bg-gray-200 rounded">N</button>
                <button onclick="setZero('fromTime')" class="text-sm px-2 py-1 bg-gray-200 rounded">Z</button>
                <button onclick="adjustTime('fromTime', 1)" class="text-sm px-2 py-1 bg-gray-200 rounded">+</button>
            </div>
        </div>

        <!-- To date -->
        <input id="toDate" type="date" class="px-3 py-2 border rounded flex-grow min-w-0 basis-0 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 my-1" />

        <!-- To time -->
        <div class="flex flex-col flex-grow min-w-0 basis-0 my-1 relative">
            <input
                id="toTime"
                type="time"
                step="1"
                class="px-3 py-2 border rounded w-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1"
                onfocus="showTimeControls('toTimeControls')"
            />
            <div id="toTimeControls" class="flex gap-1 hidden mt-1 absolute left-1/2 -translate-x-1/2 top-full z-10">
                <button onclick="adjustTime('toTime', -1)" class="text-sm px-2 py-1 bg-gray-200 rounded">‚àí</button>
                <button onclick="setNow('toTime')" class="text-sm px-2 py-1 bg-gray-200 rounded">N</button>
                <button onclick="setZero('toTime')" class="text-sm px-2 py-1 bg-gray-200 rounded">Z</button>
                <button onclick="adjustTime('toTime', 1)" class="text-sm px-2 py-1 bg-gray-200 rounded">+</button>
            </div>
        </div>


        <!-- Buttons -->
        <button
          onclick="loadMetricsWithComparison(false)"
          class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex-grow-0 flex-shrink-0 my-1"
        >
          Find
        </button>
        <button
          onclick="loadMetricsWithComparison(true)"
          class="bg-green-700 text-white px-4 py-2 rounded hover:bg-green-800 flex-grow-0 flex-shrink-0 my-1"
        >
          Summary Table
        </button>
        <button class="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900 flex-grow-0 flex-shrink-0 my-1" title="Coming soon">CDR</button>
      </div>
    </div>

    <!-- Summary Table -->
    <div id="summaryTable" class="bg-white rounded shadow hidden w-full mt-6">
      <table class="w-full table-auto">
        <thead class="text-xs text-gray-800">
<tr>
<thead class="text-xs text-gray-800">
  <tr>
   <!-- Header cells: Customer, Supplier, Destination -->
<th id="thMain" class="px-2 py-2 text-left bg-gray-200 w-[120px]" rowspan="2">
  <div class="flex items-center justify-between w-full pr-2">
    <span id="mainLabel">Customer</span>
    <span id="mainSortIcon"></span>
  </div>
</th>

<th id="thPeer" class="px-2 py-2 text-left bg-gray-100" rowspan="2">
  <div class="flex items-center justify-between w-full pr-2">
    <span id="peerLabel">Supplier</span>
    <span id="peerSortIcon"></span>
  </div>
</th>

<th class="relative px-2 py-2 text-left bg-gray-50 w-[220px]" rowspan="2">
  Destination
  <button
    onclick="sortByColumn('destination')"
    class="absolute right-1 top-1/2 -translate-y-1/2 text-blue-400 hover:text-blue-600"
    title="Sort by destination"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11l5-5 5 5M7 13l5 5 5-5" />
    </svg>
  </button>
</th>

    <th class="px-2 py-1 text-center border-l bg-gray-100" colspan="3">Min</th>
    <th class="px-2 py-1 text-center border-l bg-[#eef1ec]" colspan="3">ACD</th>
    <th class="px-2 py-1 text-center border-l bg-[#eaf1f7]" colspan="3">ASR</th>
    <th class="px-2 py-1 text-center border-l bg-gray-100" colspan="3">SCall</th>
    <th class="px-2 py-1 text-center border-l bg-[#eef1ec]" colspan="3">TCall</th>
    <th class="px-2 py-1 text-center border-l-2 bg-[#eaf1f7]" colspan="3">PDD</th>
    <th class="px-2 py-1 text-center border-l bg-gray-100" colspan="3">ATime</th>
  </tr>

 <tr>
  <!-- Min -->
  <th class="px-2 py-1 border-l bg-white">
    <div class="flex items-center justify-between">
      <span>Now</span>
      <button onclick="sortByColumn('Min')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort Min">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-50">
    <div class="flex items-center justify-between">
      <span>Y</span>
      <button onclick="sortByColumn('YMin')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort YMin">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-100">
    <div class="flex items-center justify-between">
      <span>%</span>
      <button onclick="sortByColumn('MinPct')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort Min %">‚¨ç</button>
    </div>
  </th>

  <!-- ACD -->
  <th class="px-2 py-1 border-l bg-white">
    <div class="flex items-center justify-between">
      <span>Now</span>
      <button onclick="sortByColumn('ACD')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort ACD">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-50">
    <div class="flex items-center justify-between">
      <span>Y</span>
      <button onclick="sortByColumn('YACD')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort YACD">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-100">
    <div class="flex items-center justify-between">
      <span>%</span>
      <button onclick="sortByColumn('ACDPct')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort ACD %">‚¨ç</button>
    </div>
  </th>

  <!-- ASR -->
  <th class="px-2 py-1 border-l bg-white">
    <div class="flex items-center justify-between">
      <span>Now</span>
      <button onclick="sortByColumn('ASR')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort ASR">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-50">
    <div class="flex items-center justify-between">
      <span>Y</span>
      <button onclick="sortByColumn('YASR')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort YASR">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-100">
    <div class="flex items-center justify-between">
      <span>%</span>
      <button onclick="sortByColumn('ASRPct')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort ASR %">‚¨ç</button>
    </div>
  </th>

  <!-- SCall -->
  <th class="px-2 py-1 border-l bg-white">
    <div class="flex items-center justify-between">
      <span>Now</span>
      <button onclick="sortByColumn('SCall')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort SCall">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-50">
    <div class="flex items-center justify-between">
      <span>Y</span>
      <button onclick="sortByColumn('YSCall')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort YSCall">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-100">
    <div class="flex items-center justify-between">
      <span>%</span>
      <button onclick="sortByColumn('SCallPct')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort SCall %">‚¨ç</button>
    </div>
  </th>

  <!-- TCall -->
  <th class="px-2 py-1 border-l bg-white">
    <div class="flex items-center justify-between">
      <span>Now</span>
      <button onclick="sortByColumn('TCall')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort TCall">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-50">
    <div class="flex items-center justify-between">
      <span>Y</span>
      <button onclick="sortByColumn('YTCall')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort YTCall">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-100">
    <div class="flex items-center justify-between">
      <span>%</span>
      <button onclick="sortByColumn('TCallPct')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort TCall %">‚¨ç</button>
    </div>
  </th>

  <!-- PDD -->
  <th class="px-2 py-1 border-l-2 bg-white">
    <div class="flex items-center justify-between">
      <span>Now</span>
      <button onclick="sortByColumn('PDD')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort PDD">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-50">
    <div class="flex items-center justify-between">
      <span>Y</span>
      <button onclick="sortByColumn('YPDD')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort YPDD">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-100">
    <div class="flex items-center justify-between">
      <span>%</span>
      <button onclick="sortByColumn('PDDPct')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort PDD %">‚¨ç</button>
    </div>
  </th>

  <!-- ATime -->
  <th class="px-2 py-1 border-l bg-white">
    <div class="flex items-center justify-between">
      <span>Now</span>
      <button onclick="sortByColumn('ATime')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort ATime">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-50">
    <div class="flex items-center justify-between">
      <span>Y</span>
      <button onclick="sortByColumn('YATime')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort YATime">‚¨ç</button>
    </div>
  </th>
  <th class="px-2 py-1 bg-gray-100">
    <div class="flex items-center justify-between">
      <span>%</span>
      <button onclick="sortByColumn('ATimePct')" class="text-xs text-blue-400 hover:text-blue-600 ml-1" title="Sort ATime %">‚¨ç</button>
    </div>
  </th>
</tr>
</thead>
        <tbody id="tableBody" class="divide-y divide-gray-100"></tbody>
      </table>
    </div>
  </div>

<script>

  let allSupplierData = [];

  // Merge current and yesterday metrics by customer + destination and calculate percentage change
  function mergeAndCompare(current, yesterday) {
  const yesterdayMap = {};
  yesterday.forEach(row => {
    const key = `${row.customer}|${row.destination}`;
    yesterdayMap[key] = row;
  });

  const merged = [];

  current.forEach(row => {
    const key = `${row.customer}|${row.destination}`;
    const yRow = yesterdayMap[key] || {};

    const makePct = (curr, prev) => {
      if (!prev || prev === 0) return 0;
      return +(((curr - prev) / prev) * 100).toFixed(1);
    };

    merged.push({
      customer: row.customer,
      supplier: row.supplier,
      destination: row.destination,

      Min: row.Min,
      YMin: yRow.Min || 0,
      MinPct: makePct(row.Min, yRow.Min),

      ACD: row.ACD,
      YACD: yRow.ACD || 0,
      ACDPct: makePct(row.ACD, yRow.ACD),

      ASR: row.ASR,
      YASR: yRow.ASR || 0,
      ASRPct: makePct(row.ASR, yRow.ASR),

      SCall: row.SCall,
      YSCall: yRow.SCall || 0,
      SCallPct: makePct(row.SCall, yRow.SCall),

      TCall: row.TCall,
      YTCall: yRow.TCall || 0,
      TCallPct: makePct(row.TCall, yRow.TCall),

      PDD: row.PDD,
      YPDD: yRow.PDD || 0,
      PDDPct: makePct(row.PDD, yRow.PDD),

      ATime: row.ATime,
      YATime: yRow.ATime || 0,
      ATimePct: makePct(row.ATime, yRow.ATime),

      ADur: row.ADur,
      YADur: yRow.ADur || 0,
      ADurPct: makePct(row.ADur, yRow.ADur)
    });
  });

  return merged;
}

// Group data (current or yesterday) by customer + destination
function groupByCustomerDestination(data) {
  const grouped = {};

  data.forEach(row => {
    const key = `${row.customer}|${row.destination}`;

    if (!grouped[key]) {
      grouped[key] = {
        customer: row.customer,
        destination: row.destination,
        seconds: 0,
        start_nuber: 0,
        start_attempt: 0,
        disc_reason: 0,
        pdd_total: 0,
        answer_time_total: 0,
        duration_total: 0,
        count: 0
      };
    }

    grouped[key].seconds += Number(row.seconds || 0);
    grouped[key].start_nuber += Number(row.start_nuber || 0);
    grouped[key].start_attempt += Number(row.start_attempt || 0);
    grouped[key].disc_reason += Number(row.disc_reason || 0);
    grouped[key].pdd_total += Number(row.pdd || 0);
    grouped[key].answer_time_total += Number(row.answer_time || 0);
    grouped[key].duration_total += Number(row.avg_duration || 0);
    grouped[key].count += 1;
  });

  // Convert grouped objects into array with calculated metrics
  const result = [];

  for (const key in grouped) {
    const g = grouped[key];

    result.push({
      customer: g.customer,
      destination: g.destination,
      Min: g.seconds ? Math.round(g.seconds / 60) : 0,
      ACD: g.start_nuber ? +((g.seconds / g.start_nuber / 60).toFixed(1)) : 0,
      ASR: g.start_attempt ? Math.round((g.start_nuber / g.start_attempt) * 100) : 0,
      SCall: g.start_nuber,
      TCall: g.start_attempt,
      PDD: g.count ? +(g.pdd_total / g.count / 1000).toFixed(1) : 0,
      ATime: g.count ? Math.round(g.answer_time_total / g.count) : 0,
      ADur: g.count ? +((g.duration_total / g.count / 60).toFixed(1)) : 0
    });
  }

  return result;
}

// Group by supplier + destination, and show each customer individually
function groupBySupplierDestinationCustomer(data) {
  const grouped = {};

  data.forEach(row => {
    const key = `${row.supplier}|${row.destination}|${row.customer}`;

    if (!grouped[key]) {
      grouped[key] = {
        supplier: row.supplier,
        customer: row.customer,
        destination: row.destination,
        seconds: 0,
        start_nuber: 0,
        start_attempt: 0,
        pdd_total: 0,
        answer_time_total: 0,
        duration_total: 0,
        count: 0
      };
    }

    grouped[key].seconds += Number(row.seconds || 0);
    grouped[key].start_nuber += Number(row.start_nuber || 0);
    grouped[key].start_attempt += Number(row.start_attempt || 0);
    grouped[key].pdd_total += Number(row.pdd || 0);
    grouped[key].answer_time_total += Number(row.answer_time || 0);
    grouped[key].duration_total += Number(row.avg_duration || 0);
    grouped[key].count += 1;
  });

  return Object.values(grouped).map(g => ({
    supplier: g.supplier,
    customer: g.customer,
    destination: g.destination,
    Min: g.seconds ? Math.round(g.seconds / 60) : 0,
    ACD: g.start_nuber ? +((g.seconds / g.start_nuber / 60).toFixed(1)) : 0,
    ASR: g.start_attempt ? Math.round((g.start_nuber / g.start_attempt) * 100) : 0,
    SCall: g.start_nuber,
    TCall: g.start_attempt,
    PDD: g.count ? +(g.pdd_total / g.count / 1000).toFixed(1) : 0,
    ATime: g.count ? Math.round(g.answer_time_total / g.count) : 0,
    ADur: g.count ? +((g.duration_total / g.count / 60).toFixed(1)) : 0
  }));
}

// Group data by supplier and destination
function groupBySupplierDestination(data) {
  const grouped = {};

  data.forEach(row => {
    const key = `${row.supplier}|${row.destination}`;

    // Initialize new group if not yet created
    if (!grouped[key]) {
      grouped[key] = {
        supplier: row.supplier,
        destination: row.destination,
        seconds: 0,
        start_nuber: 0,
        start_attempt: 0,
        pdd_total: 0,
        answer_time_total: 0,
        duration_total: 0,
        count: 0
      };
    }

    // Accumulate values for metrics
    grouped[key].seconds += Number(row.seconds || 0);
    grouped[key].start_nuber += Number(row.start_nuber || 0);
    grouped[key].start_attempt += Number(row.start_attempt || 0);
    grouped[key].pdd_total += Number(row.pdd || 0);
    grouped[key].answer_time_total += Number(row.answer_time || 0);
    grouped[key].duration_total += Number(row.avg_duration || 0);
    grouped[key].count += 1;
  });

  // Convert grouped data into final array with calculated metrics
  return Object.values(grouped).map(g => ({
    supplier: g.supplier,
    destination: g.destination,
    Min: g.seconds ? Math.round(g.seconds / 60) : 0,
    ACD: g.start_nuber ? +((g.seconds / g.start_nuber / 60).toFixed(1)) : 0,
    ASR: g.start_attempt ? Math.round((g.start_nuber / g.start_attempt) * 100) : 0,
    SCall: g.start_nuber,
    TCall: g.start_attempt,
    PDD: g.count ? +(g.pdd_total / g.count / 1000).toFixed(1) : 0,
    ATime: g.count ? Math.round(g.answer_time_total / g.count) : 0,
    ADur: g.count ? +((g.duration_total / g.count / 60).toFixed(1)) : 0
  }));
}

function loadMetricsWithComparison(showTable = false) {
  console.log("üü° reverseMode =", reverseMode);

  // Hide summary table if not requested
  if (!showTable) {
    document.getElementById("summaryTable").classList.add("hidden");
  }

  // Update table header labels and sort icons
  updateSortIcons();

  // Collect input filter values
  const customer = document.getElementById("customerInput").value.trim();
  const supplier = document.getElementById("supplierInput").value.trim();
  const destination = document.getElementById("destinationInput").value.trim();
  const from = document.getElementById("fromDate").value + 'T' + document.getElementById("fromTime").value;
  const to = document.getElementById("toDate").value + 'T' + document.getElementById("toTime").value;

  // Calculate 24h ago time range
  const from_y = new Date(new Date(from).getTime() - 24 * 60 * 60 * 1000).toISOString();
  const to_y = new Date(new Date(to).getTime() - 24 * 60 * 60 * 1000).toISOString();

  // Prepare URL query strings
  const paramsToday = new URLSearchParams({ customer, supplier, destination, from, to });
  const paramsYesterday = new URLSearchParams({ customer, supplier, destination, from: from_y, to: to_y });

  // Fetch both datasets (today and yesterday)
  Promise.all([
    fetch(`/api/metrics?${paramsToday}`).then(r => r.json()),
    fetch(`/api/metrics?${paramsYesterday}`).then(r => r.json())
  ])
  .then(([current, yesterday]) => {
    allSupplierData = current;

    const groupedCurrent = reverseMode
      ? groupBySupplierDestination(current)
      : groupByCustomerDestination(current);

    const groupedYesterday = reverseMode
      ? groupBySupplierDestination(yesterday)
      : groupByCustomerDestination(yesterday);

    finalTable = mergeAndCompare(groupedCurrent, groupedYesterday);

    if (showTable) {
  renderTable(); // Show table only if explicitly requested
  document.getElementById("summaryTable").classList.remove("hidden");
} else {
  // Hide table if user only clicked "Find"
  document.getElementById("summaryTable").classList.add("hidden");
}
  })
  .catch(error => {
    console.error("‚ùå Error loading metrics:", error);
  });
}
    
    
    function showTimeControls(id) {
      document.getElementById(id).classList.remove("hidden");
    }

    function hideTimeControls(id) {
      setTimeout(() => {
        document.getElementById(id).classList.add("hidden");
      }, 200);
    }

    function adjustTime(id, hoursDelta) {
      const timeInput = document.getElementById(id);
      const dateInput = document.getElementById(id === "fromTime" ? "fromDate" : "toDate");
      const currentDate = new Date(dateInput.value + 'T' + timeInput.value + 'Z');
      currentDate.setUTCHours(currentDate.getUTCHours() + hoursDelta);
      timeInput.value = currentDate.toISOString().substr(11, 8);
      dateInput.value = currentDate.toISOString().substr(0, 10);
    }

    function setNow(id) {
      const now = new Date();
      document.getElementById(id).value = now.toISOString().substr(11, 8);
      document.getElementById(id === "fromTime" ? "fromDate" : "toDate").value = now.toISOString().substr(0, 10);
    }

    function setZero(id) {
      document.getElementById(id).value = "00:00:00";
    }

    function setDefaultDateRange() {
      const now = new Date();
      const from = new Date(now.getTime() - 24 * 60 * 60 * 1000);
      document.getElementById("fromDate").value = from.toISOString().slice(0, 10);
      document.getElementById("fromTime").value = from.toISOString().slice(11, 19);
      document.getElementById("toDate").value = now.toISOString().slice(0, 10);
      document.getElementById("toTime").value = now.toISOString().slice(11, 19);
    }

function toggleSuppliers(button) {
  const main = button.dataset.main;
  const destination = button.dataset.destination;
  const currentRow = button.closest("tr");

  console.log("üîç Expand requested:");
  console.log("Mode:", reverseMode ? "Supplier ‚Üí Customers" : "Customer ‚Üí Suppliers");
  console.log("Main:", main, "Destination:", destination);

  // Check if current row is already expanded (has any supplier-row after it)
  let next = currentRow.nextElementSibling;
  let isAlreadyExpanded = false;
  while (next && next.classList.contains("supplier-row")) {
    isAlreadyExpanded = true;
    break;
  }

  // Always remove all open supplier and hourly rows
  document.querySelectorAll(".supplier-row, .hourly-row").forEach(row => row.remove());

  // Reset all main row expand buttons to "+"
  document.querySelectorAll("button[data-main]").forEach(btn => {
    btn.textContent = "+";
  });

  // If the current row was expanded, do not expand again
  if (isAlreadyExpanded) return;

  // Mark current button as expanded
  button.textContent = "‚àí";

  // Filter rows based on current mode
  const filtered = reverseMode
    ? allSupplierData.filter(row =>
        row.supplier === main && row.destination === destination)
    : allSupplierData.filter(row =>
        row.customer === main && row.destination === destination);

  // Group the filtered data
  const grouped = reverseMode
    ? groupBySupplierDestinationCustomer(filtered)
    : groupByCustomerDestinationSupplier(filtered);

  console.log("Grouped rows:", grouped);

  // Build HTML for inserted rows
  const rowsHTML = grouped.map(s => {
    const name = reverseMode ? s.customer : s.supplier;

    return `
  <tr class="supplier-row bg-gray-100 hover:bg-gray-200 text-sm text-black text-right border-t border-dashed border-gray-300">
    
    <!-- First column: EMPTY to avoid duplication -->
    <td></td>

    <!-- Second column: peer (client or supplier) with + -->
    <td class="px-2 py-1 text-left">
      <div class="flex items-center gap-0 pl-1">
        <button
          class="text-sm text-blue-600 hover:no-underline"
          data-main="${main}"
          data-peer="${name}"
          data-destination="${s.destination}"
          onclick="toggleHourly(this)"
        >
          +
        </button>
        <span class="ml-1">${name}</span>
      </div>
    </td>

    <!-- Third column: Destination -->
    <td class="px-2 py-1 text-left text-gray-500">${s.destination}</td>

    <!-- Metrics -->
    <td class="px-2 py-1 border-l">${s.Min}</td>
    <td class="px-2 py-1">${s.YMin ?? 0}</td>
    <td class="px-2 py-1 bg-gray-50">${s.MinPct ?? 0}</td>

    <td class="px-2 py-1 border-l">${s.ACD}</td>
    <td class="px-2 py-1">${s.YACD ?? 0}</td>
    <td class="px-2 py-1 bg-gray-50">${s.ACDPct ?? 0}</td>

    <td class="px-2 py-1 border-l">${s.ASR}</td>
    <td class="px-2 py-1">${s.YASR ?? 0}</td>
    <td class="px-2 py-1 bg-gray-50">${s.ASRPct ?? 0}</td>

    <td class="px-2 py-1 border-l">${s.SCall}</td>
    <td class="px-2 py-1">${s.YSCall ?? 0}</td>
    <td class="px-2 py-1 bg-gray-50">${s.SCallPct ?? 0}</td>

    <td class="px-2 py-1 border-l">${s.TCall}</td>
    <td class="px-2 py-1">${s.YTCall ?? 0}</td>
    <td class="px-2 py-1 bg-gray-50">${s.TCallPct ?? 0}</td>

    <td class="px-2 py-1 border-l-2">${s.PDD}</td>
    <td class="px-2 py-1">${s.YPDD ?? 0}</td>
    <td class="px-2 py-1 bg-gray-50">${s.PDDPct ?? 0}</td>

    <td class="px-2 py-1 border-l">${s.ATime}</td>
    <td class="px-2 py-1">${s.YATime ?? 0}</td>
    <td class="px-2 py-1 bg-gray-50">${s.ATimePct ?? 0}</td>
  </tr>
`;
    }).join("");

    // Insert rows after the clicked row
    currentRow.insertAdjacentHTML("afterend", rowsHTML);
    }

  function toggleHourly(button) {
  const currentRow = button.closest("tr");

  // Remove all rows with class hourly-row until reaching something else
  let next = currentRow.nextElementSibling;
  let hasRemoved = false;

  while (next && next.classList.contains("hourly-row")) {
    const toRemove = next;
    next = next.nextElementSibling;
    toRemove.remove();
    hasRemoved = true;
  }

  if (hasRemoved) {
    button.textContent = "+";
    return;
  }

  button.textContent = "‚àí";

  const main = button.dataset.main;
  const peer = button.dataset.peer;
  const destination = button.dataset.destination;
  const nameToShowInPeer = reverseMode ? peer : peer;

  const from = new Date(document.getElementById("fromDate").value + "T" + document.getElementById("fromTime").value);
  const to = new Date(document.getElementById("toDate").value + "T" + document.getElementById("toTime").value);

  const filtered = allSupplierData.filter(row =>
    row.customer === (reverseMode ? peer : main) &&
    row.supplier === (reverseMode ? main : peer) &&
    row.destination === destination
  );

  const hourlyMap = {};

  filtered.forEach(row => {
    const hour = new Date(row.time);
    hour.setMinutes(0, 0, 0);
    const hourKey = hour.toISOString().slice(11, 16);

    if (!hourlyMap[hourKey]) {
      hourlyMap[hourKey] = {
        hour: hourKey,
        destination: row.destination,
        seconds: 0,
        start_nuber: 0,
        start_attempt: 0,
        pdd_total: 0,
        answer_time_total: 0,
        count: 0
      };
    }

    const g = hourlyMap[hourKey];
    g.seconds += Number(row.seconds || 0);
    g.start_nuber += Number(row.start_nuber || 0);
    g.start_attempt += Number(row.start_attempt || 0);
    g.pdd_total += Number(row.pdd || 0);
    g.answer_time_total += Number(row.answer_time || 0);
    g.count += 1;
  });

  const rows = Object.values(hourlyMap).sort((a, b) => a.hour.localeCompare(b.hour)).map(h => {
  const Min = h.seconds ? Math.round(h.seconds / 60) : 0;
  const ACD = h.start_nuber ? +((h.seconds / h.start_nuber / 60).toFixed(1)) : 0;
  const ASR = h.start_attempt ? Math.round((h.start_nuber / h.start_attempt) * 100) : 0;
  const PDD = h.count ? +(h.pdd_total / h.count / 1000).toFixed(1) : 0;
  const ATime = h.count ? Math.round(h.answer_time_total / h.count) : 0;

  return `
    <tr class="hourly-row text-sm text-right bg-gray-50 border-t border-dashed border-gray-300">
      <!-- Column: main (indented hour) -->
      <td class="px-2 py-1 text-xs text-gray-500">
        <div class="flex justify-end pr-2">${h.hour}</div>
      </td>

      <!-- Column: supplier or customer -->
      <td class="px-2 py-1 text-left text-gray-500 text-xs">
        ${peer}
      </td>

      <!-- Column: destination -->
      <td class="px-2 py-1 text-left text-gray-500 text-xs">${h.destination}</td>

      <!-- Metrics -->
      <td class="px-2 py-1 border-l">${Min}</td>
      <td class="px-2 py-1">-</td>
      <td class="px-2 py-1 bg-gray-50">-</td>
      <td class="px-2 py-1">${ACD}</td>
      <td class="px-2 py-1">-</td>
      <td class="px-2 py-1 bg-gray-50">-</td>
      <td class="px-2 py-1">${ASR}</td>
      <td class="px-2 py-1">-</td>
      <td class="px-2 py-1 bg-gray-50">-</td>
      <td class="px-2 py-1">${h.start_nuber}</td>
      <td class="px-2 py-1">-</td>
      <td class="px-2 py-1 bg-gray-50">-</td>
      <td class="px-2 py-1">${h.start_attempt}</td>
      <td class="px-2 py-1">-</td>
      <td class="px-2 py-1 bg-gray-50">-</td>
      <td class="px-2 py-1 border-l-2">${PDD}</td>
      <td class="px-2 py-1">-</td>
      <td class="px-2 py-1 bg-gray-50">-</td>
      <td class="px-2 py-1">${ATime}</td>
      <td class="px-2 py-1">-</td>
      <td class="px-2 py-1 bg-gray-50">-</td>
    </tr>
  `;
}).join("");

  currentRow.insertAdjacentHTML("afterend", rows);
}

  // Group data by customer + destination + supplier
  function groupByCustomerDestinationSupplier(data) {
    const grouped = {};
    data.forEach(row => {
      const key = `${row.customer}|${row.destination}|${row.supplier}`;
      if (!grouped[key]) {
        grouped[key] = {
          customer: row.customer,
          destination: row.destination,
          supplier: row.supplier,
          seconds: 0,
          start_nuber: 0,
          start_attempt: 0,
          pdd_total: 0,
          answer_time_total: 0,
          duration_total: 0,
          count: 0
        };
      }
      grouped[key].seconds += Number(row.seconds || 0);
      grouped[key].start_nuber += Number(row.start_nuber || 0);
      grouped[key].start_attempt += Number(row.start_attempt || 0);
      grouped[key].pdd_total += Number(row.pdd || 0);
      grouped[key].answer_time_total += Number(row.answer_time || 0);
      grouped[key].duration_total += Number(row.avg_duration || 0);
      grouped[key].count += 1;
    });

    return Object.values(grouped).map(g => ({
      customer: g.customer,
      supplier: g.supplier,
      destination: g.destination,

      Min: g.seconds ? Math.round(g.seconds / 60) : 0,
      ACD: g.start_nuber ? +((g.seconds / g.start_nuber / 60).toFixed(1)) : 0,
      ASR: g.start_attempt ? Math.round((g.start_nuber / g.start_attempt) * 100) : 0,
      SCall: g.start_nuber,
      TCall: g.start_attempt,
      PDD: g.count ? +(g.pdd_total / g.count / 1000).toFixed(1) : 0,
      ATime: g.count ? Math.round(g.answer_time_total / g.count) : 0,
      ADur: g.count ? +((g.duration_total / g.count / 60).toFixed(1)) : 0
    }));
  }

// Store the final table data globally to reuse it for sorting
let finalTable = [];

// Track current sorting state
let currentSort = {
  column: null,
  asc: true
};

// Sort finalTable by selected column and direction
function sortByColumn(column) {
  // Do nothing if there is no data
  if (!finalTable.length) return;

  // Toggle sort direction if clicking the same column again
  if (currentSort.column === column) {
    currentSort.asc = !currentSort.asc;
  } else {
    currentSort.column = column;
    currentSort.asc = true;
  }

  // Perform sorting
  finalTable.sort((a, b) => {
    const valA = a[column];
    const valB = b[column];

    // Move null/undefined to the bottom
    if (valA == null) return 1;
    if (valB == null) return -1;

    // If numbers, do numeric sort
    if (typeof valA === "number" && typeof valB === "number") {
      return currentSort.asc ? valA - valB : valB - valA;
    }

    // Otherwise, do alphabetical sort
    return currentSort.asc
      ? String(valA).localeCompare(String(valB))
      : String(valB).localeCompare(String(valA));
  });

  // Re-render the table with sorted data
  renderTable();
}

  // Renders the summary table from the global finalTable array
  function renderTable() {
  // Get reference to table body and clear it
  const table = document.getElementById("tableBody");
  table.innerHTML = "";

  // Loop through all rows and render them
  finalTable.forEach(row => {
    const main = reverseMode ? row.supplier : row.customer;
    const peer = reverseMode ? row.customer : row.supplier;

    table.innerHTML += `
      <tr class="hover:bg-gray-200 text-sm text-right">
        <td class="px-2 py-1 text-left">
  <div class="flex items-center gap-1">
    <button
      class="text-sm text-blue-600 hover:no-underline"
      data-main="${main}"
      data-destination="${row.destination}"
      onclick="toggleSuppliers(this)"
    >
      +
    </button>
    <span>${main}</span>
  </div>
</td>

        <td class="px-2 py-1 text-left">${peer || ""}</td>
        <td class="px-2 py-1 text-left">${row.destination}</td>

        <td class="px-2 py-1 border-l">${row.Min}</td>
        <td class="px-2 py-1">${row.YMin != null ? row.YMin : 0}</td>
        <td class="px-2 py-1 bg-gray-50">${row.MinPct != null ? row.MinPct : 0}</td>

        <td class="px-2 py-1 border-l">${row.ACD}</td>
        <td class="px-2 py-1">${row.YACD != null ? row.YACD : 0}</td>
        <td class="px-2 py-1 bg-gray-50">${row.ACDPct != null ? row.ACDPct : 0}</td>

        <td class="px-2 py-1 border-l">${row.ASR}</td>
        <td class="px-2 py-1">${row.YASR != null ? row.YASR : 0}</td>
        <td class="px-2 py-1 bg-gray-50">${row.ASRPct != null ? row.ASRPct : 0}</td>

        <td class="px-2 py-1 border-l">${row.SCall}</td>
        <td class="px-2 py-1">${row.YSCall != null ? row.YSCall : 0}</td>
        <td class="px-2 py-1 bg-gray-50">${row.SCallPct != null ? row.SCallPct : 0}</td>

        <td class="px-2 py-1 border-l">${row.TCall}</td>
        <td class="px-2 py-1">${row.YTCall != null ? row.YTCall : 0}</td>
        <td class="px-2 py-1 bg-gray-50">${row.TCallPct != null ? row.TCallPct : 0}</td>

        <td class="px-2 py-1 border-l-2">${row.PDD}</td>
        <td class="px-2 py-1">${row.YPDD != null ? row.YPDD : 0}</td>
        <td class="px-2 py-1 bg-gray-50">${row.PDDPct != null ? row.PDDPct : 0}</td>

        <td class="px-2 py-1 border-l">${row.ATime}</td>
        <td class="px-2 py-1">${row.YATime != null ? row.YATime : 0}</td>
        <td class="px-2 py-1 bg-gray-50">${row.ATimePct != null ? row.ATimePct : 0}</td>

      </tr>
    `;
  });
  // Make sure the table is visible
  document.getElementById("summaryTable").classList.remove("hidden");
  // After rendering the table, update sorting buttons in the header
}

  let reverseMode = false;

  function toggleReverse() {
  reverseMode = !reverseMode;

  const button = document.getElementById("reverseButton");
    if (reverseMode) {
      button.classList.remove("bg-gray-200");
      button.classList.add("bg-gray-500", "text-white");
    } else {
      button.classList.remove("bg-gray-500", "text-white");
      button.classList.add("bg-gray-200");
    }
  }

  // Render correct sort buttons depending on reverseMode state
function updateSortIcons() {
  const mainLabel = document.getElementById("mainLabel");
  const peerLabel = document.getElementById("peerLabel");
  const mainIcon = document.getElementById("mainSortIcon");
  const peerIcon = document.getElementById("peerSortIcon");

  if (reverseMode) {
    mainLabel.textContent = "Supplier";
    mainIcon.innerHTML = getSortButtonHTML("supplier");

    peerLabel.textContent = "Customer";
    peerIcon.innerHTML = getSortButtonHTML("customer");
  } else {
    mainLabel.textContent = "Customer";
    mainIcon.innerHTML = getSortButtonHTML("customer");

    peerLabel.textContent = "Supplier";
    peerIcon.innerHTML = getSortButtonHTML("supplier");
  }
}

// Generate sort button HTML for a given field
function getSortButtonHTML(field) {
  return `
    <button onclick="sortByColumn('${field}')" class="text-blue-400 hover:text-blue-600" title="Sort ${field}">
      <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11l5-5 5 5M7 13l5 5 5-5" />
      </svg>
    </button>
  `;
}


    function loadMetrics(showTable = false) {
      const params = new URLSearchParams({
        customer: document.getElementById("customerInput").value.trim(),
        supplier: document.getElementById("supplierInput").value.trim(),
        destination: document.getElementById("destinationInput").value.trim(),
        from: document.getElementById("fromDate").value + 'T' + document.getElementById("fromTime").value,
        to: document.getElementById("toDate").value + 'T' + document.getElementById("toTime").value
      });



      fetch(`/api/metrics?${params.toString()}`)
        .then(response => response.json())
        .then(data => {
          const table = document.getElementById("tableBody");
          table.innerHTML = "";

          if (!Array.isArray(data) || data.length === 0) {
            table.innerHTML = `<tr><td colspan="7" class="px-4 py-2 text-gray-500">${Array.isArray(data) ? "No data found" : "Error loading data"}</td></tr>`;
            return;
          }

          data.forEach(row => {
            const acd = row.seconds && row.start_nuber ? (row.seconds / row.start_nuber).toFixed(1) : 0;
            const asr = row.start_attempt ? Math.round((row.start_nuber / row.start_attempt) * 100) : 0;
            const totalMin = Math.round(row.seconds / 60);

            table.innerHTML += `
              <tr class="hover:bg-gray-50">
                <td class="px-4 py-2">${row.time}</td>
                <td class="px-4 py-2">${row.customer}</td>
                <td class="px-4 py-2">${row.supplier}</td>
                <td class="px-4 py-2">${row.destination}</td>
                <td class="px-4 py-2">${acd}</td>
                <td class="px-4 py-2">${asr}%</td>
                <td class="px-4 py-2">${totalMin}</td>
              </tr>`;
          });

          if (showTable) {
            document.getElementById("summaryTable").classList.remove("hidden");
          }
        })
        .catch(error => {
          console.error("Fetch error:", error);
          document.getElementById("tableBody").innerHTML = `<tr><td colspan="7" class="text-red-600 px-4 py-2">Request failed</td></tr>`;
          });          


          // Auto-hide time control panels when clicking outside
          document.addEventListener("click", function (event) {
          const fromPanel = document.getElementById("fromTimeControls");
          const toPanel = document.getElementById("toTimeControls");
          const fromInput = document.getElementById("fromTime");
          const toInput = document.getElementById("toTime");

          const isClickInsideFrom = fromInput.contains(event.target) || fromPanel.contains(event.target);
          const isClickInsideTo = toInput.contains(event.target) || toPanel.contains(event.target);

          if (!isClickInsideFrom) fromPanel.classList.add("hidden");
          if (!isClickInsideTo) toPanel.classList.add("hidden");
          });
    }

    setDefaultDateRange();
    loadMetrics();
  </script>
</body>
</html>